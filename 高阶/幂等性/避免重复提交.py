#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
消费者在消费mq中的消息时，mq已经把消息发送给消费者，消费者在给mq返回ack时，网络中断，故mq没有收到确认消息，则该条消息会重新发送给其他消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已经成功消费了该消息，造成了消费者消费了重复的消息.
解决思路：
1.唯一id+指纹码机制：当消费者消费信息时，先查询数据库中有没有用户同样需求的唯一码（该码应该包含时间戳），如果有则表示之前已经消费过了则不在此消费，如果没有则继续录入数据库。
2.使用redis的原子性，redis执行sentnx命令，天然具有幂等性。实现不重复消费.
Redis Setnx（SET if Not eXists） 命令在指定的 key 不存在时，为 key 设置指定的值。


每个消费者接到消息后，第一时间查询redis数据库有没有相同指纹码，如果没有则将指纹码写入redis数据库，且开始执行任务。
如果使用在redis中查询到了相同指纹码，则执行另一个任务（调用接口反馈给客户端异常）
"""
